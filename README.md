# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

# Задание 1. Анализ и планирование
### 1. Описание функциональности монолитного приложения

Текущая версия приложения "умный дом" обеспечивает следующие функции:
- управление отоплением
- мониторинг температуры
  
**Управление отоплением:**

- Пользователь может удалённо включать/выключать отопление в доме
- Для доступности функции требуется монтаж оборудования(реле) в доме специалистом, первичная регистрация оборудования в системе

**Мониторинг температуры:**

- Пользователь может просматривать текущую температуру в доме через веб-интерфейс приложения
- Система получает данные о температуре с датчиков, установленных в помещениях 
- Для доступности функции требуется монтаж оборудования(датчик) в доме  специалистом, первичная регистрация оборудования в системе

### 2. Анализ архитектуры монолитного приложения

Приложение реализовано в монолитном стиле и содержит следующие компоненты:
#### 1.Cлой представления реализован в виде веб-приложения, доступного через браузер, язык реализации - не известен.
#### 2.Cлой бизнес-логики реализован в виде:
##### 2.1. бэкенд приложения, которое разворачивается как единый контейнер, язык программирования - Golang
##### 2.2. слой исполнения - физические устройства (датчики и реле), выполняющие команды на физическом уровне
#### 3.Cлой хранения данных представлен в виде единой СУБД - PostgreSQL.

Коммуникация компонентов - синхронная.
Use cases коммуникации
```[Управление отоплением](./diagrams/diagrams_as_is/use_cases/heatingManagementSequenceDiagram.puml)```

```[Мониторинг температуры](./diagrams/diagrams_as_is/use_cases/temperatureRetrievingSequenceDiagram.puml)```

### 3. Определение доменов и границы контекстов
```markdown
[System subdomains and bounded contexts](./diagrams/diagrams_as_is/container/sundomains_containers.pumldiagrams/diagrams_as_is/container/sundomains_containers.puml)
```

### **4. Проблемы монолитного решения**

- Низкая отказоустройчивость системы: если один из модулей системы выходит из строя, не работают остальные компоненты
- Низкая изменяемость(modiafability) системы и отсутствие возможности ее масштабировать: нет возможности бесшовно подключить новую функциональность, добавить новый модуль умного устройства 
- Низкая отказоустойчивость системы
- Низкая развертываемость(deployability) системы: что внесения новой функциональности требуется остановка работы всего приложения 
- Высокая связность компонентов из-за использования исключительно синхронной коммуникации: если бэкенд-приложение отправляет команду уйстройству умного дома, оно ждет ответа устройства. Как следствие, растет нагрузка на серверы бэкенд-приложения.

### 5. Визуализация контекста системы — диаграмма С4
```[Диаграмма контекста системы](./diagrams/diagrams_as_is/context/context_diagram.puml)```

# Задание 2. Проектирование микросервисной архитектуры

В связи с новыми требованиями функциональности принято решение пересмотреть архитурный стиль приложения. Проведен анализ бизнес-модели приложения с целью определить границы функций.

**Диаграмма контейнеров (Containers)**

```[Предлагаемая диаграмма основых систем (контейнеров)](./diagrams/diagrams_to_be/c4/container_diagram.puml)```

**Диаграмма компонентов (Components)**

```[Предлагаемая диаграмма микросервисов (компонентов)](./diagrams/diagrams_to_be/c4/component_diagram.puml)```

**Диаграмма кода (Code)**

В качестве детального описания ключевых сценариев использования предлагается набор use-case-ов
```[Самостоятельное подключение(регистрация) устройства умного дома пользователем](./diagrams/diagrams_to_be/use_cases/new_device_registration.puml)```

```[Создание сценария автоматического срабатывания устройства пользователем](./diagrams/diagrams_to_be/use_cases/device_scenario_creation.puml)```


# Задание 3. Разработка ER-диаграммы

```[ER-диаграмма сущностей системы](./diagrams/diagrams_to_be/er_diagram.puml)```

# Задание 4. Создание и документирование API

### 1. Тип API

Данный раздел описывает типы коммуникации между микросервисами приложения "Умный дом".
Структура микросервисов доступна в ```[диаграмм компонентов систесы](./diagrams/diagrams_to_be/c4/component_diagram.puml)```
Типы коммуникации микросервисов:
Стартовая страница и дашборд - Страница домов и помещений - роутинг
Стартовая страница и дашборд - Страница устройств - роутинг
Стартовая страница и дашборд - Страница сценариев устройств - роутинг
Страница домов и помещений - House and locations API - синхронный REST API, потому что пользователю нужно оперативно видеть результат своей деятельности
Страница устройств - Devices API - синхронно, аналогично
Страница сценариев устройств - Scenarios API - синхронно, аналогично
Scenarios API - TriggerEngine - ассинхронная event-driven коммуникация через брокер очередей, во-первых для удаления излишней связности между системами + запуск сценариев не требуется пользователю оперативно, а будет происходить в соответствии с настроенными триггерами
TriggerEngine - TaskWorker - ассинхронная event-driven коммуникация через брокер очередей, для избегания появления излишней связности между данными контекстами
TaskWorker - Устройство умного дома - синхронная коммуникация, поскольку это прямая команда устройству выполнять сценарий работы
TelemetryListener - TriggerEngine - ассинхронная event-driven коммуникация через брокер очередей, избегание перетекания нагрузки больших объемов данных на TriggerEngine

### 2. Документация API

```[SmartHome API](./smarthome-api.yaml)```
```[SmartHome async API](./smarthome-asyncapi.yaml)```

# Задание 5. Работа с docker и docker-compose

Перейдите в apps.

Там находится приложение-монолит для работы с датчиками температуры. В README.md описано как запустить решение.

Вам нужно:

1) сделать простое приложение temperature-api на любом удобном для вас языке программирования, которое при запросе /temperature?location= будет отдавать рандомное значение температуры.

Locations - название комнаты, sensorId - идентификатор названия комнаты

```
	// If no location is provided, use a default based on sensor ID
	if location == "" {
		switch sensorID {
		case "1":
			location = "Living Room"
		case "2":
			location = "Bedroom"
		case "3":
			location = "Kitchen"
		default:
			location = "Unknown"
		}
	}

	// If no sensor ID is provided, generate one based on location
	if sensorID == "" {
		switch location {
		case "Living Room":
			sensorID = "1"
		case "Bedroom":
			sensorID = "2"
		case "Kitchen":
			sensorID = "3"
		default:
			sensorID = "0"
		}
	}
```

2) Приложение следует упаковать в Docker и добавить в docker-compose. Порт по умолчанию должен быть 8081

3) Кроме того для smart_home приложения требуется база данных - добавьте в docker-compose файл настройки для запуска postgres с указанием скрипта инициализации docker-compose down -v

Для проверки можно использовать Postman коллекцию smarthome-api.postman_collection.json и вызвать:

- Create Sensor
- Get All Sensors

Должно при каждом вызове отображаться разное значение температуры

Ревьюер будет проверять точно так же.


